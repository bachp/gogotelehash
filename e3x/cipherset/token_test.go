package cipherset

import (
	"testing"
)

func TestExtractToken(t *testing.T) {
	var tab = []struct {
		Msg   []byte
		Token Token
	}{
		// no token
		{[]byte{}, ZeroToken},
		{[]byte{0x00}, ZeroToken},
		{[]byte{0x00, 0x00}, ZeroToken},
		{[]byte{0x00, 0x01, 0x1a}, ZeroToken},

		// channel packet tokens
		{
			[]byte{
				0x00, 0x00,
				0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
				0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08},
			Token{
				0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
				0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08}},

		// message tokens
		{
			[]byte{
				0x00, 0x01, 0x1a,
				0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
				0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08},
			Token{
				0x8c, 0x8d, 0x56, 0x4f, 0x87, 0x3f, 0xa1, 0x88,
				0xac, 0x07, 0x86, 0x0a, 0x7b, 0xd2, 0xf3, 0xbc}},
	}

	for idx, row := range tab {
		actual := ExtractToken(row.Msg)
		if row.Token != actual {
			t.Errorf("%d: expected %s but was %s", idx, row.Token, actual)
		}
	}
}

func BenchmarkExtractTokenOther(b *testing.B) {
	msg := []byte{0x00, 0x01, 0x1a}

	for i := 0; i < b.N; i++ {
		_ = ExtractToken(msg)
	}
}

func BenchmarkExtractTokenPacket(b *testing.B) {
	msg := []byte{
		0x00, 0x00,
		0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
		0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08}

	for i := 0; i < b.N; i++ {
		_ = ExtractToken(msg)
	}
}

func BenchmarkExtractTokenMessage(b *testing.B) {
	msg := []byte{
		0x00, 0x01, 0x1a,
		0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
		0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08}

	for i := 0; i < b.N; i++ {
		_ = ExtractToken(msg)
	}
}
